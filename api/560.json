{"title":"用fastCGI协议进行RPC调用","zzzContent":"近来由于业务量急剧增长,业务种类越来越多,RPC混乱问题就凸现出来.\n具体表现是:\na1,a2,a3,a4 为一组服务器,为用户提供A服务.\nb1,b2,b3为一组服务器,为用户提供B服务.\nc1,c2,c3为一组服务器,为用户提供C服务.\n最初各服务器各自服务是不太相关的.随着业务拓展,用户提出新的需求,我们需要\n在A服务中调用B组服务器的API接口.\n....\n最后我们发现这样一个现象:\n用户请求a1 提供服务.a1发现他需要知道另一些数据,于是调用b2的rpc服务.但是b2\n上这个数据又需要c3的RPC.结果c3又需要a2来提供一些数据....\n我们的远程调用调来调去,最后把自己调晕了.\n\n于是我开始考虑一种解决方案。\n首先当然是：对远程调用加以控制和规范，避免不必要的远程调用。\n接着我注意到，我们利用CURL来通过http通道进行远程调用其实是没必要的。我可以在做远程调用时，走FastCGI协议。\n\n说干就干:\n第一步：建立一个fastCGI:<a href=\"http://www.162cm.com/wp-content/uploads/2007/12/spawn-php.txt\" title=\"spawn-php\">spawn-php</a>\n<coolcode file=\"http://www.162cm.com/wp-content/uploads/2007/12/spawn-php.txt\">\n#!/bin/bash\n\n## ABSOLUTE path to the spawn-fcgi binary\nSPAWNFCGI=\"/home/y/opt/lighttpd/bin/spawn-fcgi\"\n\n## ABSOLUTE path to the PHP binary\nFCGIPROGRAM=\"/home/y/opt/php/bin/php-cgi\"\n\n## TCP port to which to bind on localhost\nFCGIPORT=\"1026\"\n\n## number of PHP children to spawn\nPHP_FCGI_CHILDREN=10\n\n## maximum number of requests a single PHP process can serve before it is restarted\nPHP_FCGI_MAX_REQUESTS=1000\n\n## IP addresses from which PHP should access server connections\nFCGI_WEB_SERVER_ADDRS=\"127.0.0.1,192.168.2.10\"\n\n# allowed environment variables, separated by spaces\nALLOWED_ENV=\"ORACLE_HOME PATH USER\"\n\n## if this script is run as root, switch to the following user\nUSERID=y\nGROUPID=y\n\n################## no config below this line\n\nif test x$PHP_FCGI_CHILDREN = x; then\nPHP_FCGI_CHILDREN=5\nfi\n\nexport PHP_FCGI_MAX_REQUESTS\nexport FCGI_WEB_SERVER_ADDRS\n\nALLOWED_ENV=\"$ALLOWED_ENV PHP_FCGI_MAX_REQUESTS FCGI_WEB_SERVER_ADDRS\"\n\nif test x$UID = x0; then\nEX=\"$SPAWNFCGI -p $FCGIPORT -f $FCGIPROGRAM -u $USERID -g $GROUPID -C $PHP_FCGI_CHILDREN\"\nelse\nEX=\"$SPAWNFCGI -p $FCGIPORT -f $FCGIPROGRAM -C $PHP_FCGI_CHILDREN\"\nfi\n\n# copy the allowed environment variables\nE=\n\nfor i in $ALLOWED_ENV; do\nE=\"$E $i=${!i}\"\ndone\n\n# clean the environment and set up a new one\nenv - $E $EX\n</coolcode>\n2.接着我们建立这样的文件：<a href=\"http://www.162cm.com/wp-content/uploads/2007/12/http.txt\" title=\"http.txt\">http.txt</a>\n<coolcode file=\"http://www.162cm.com/wp-content/uploads/2007/12/http.txt\">\nfor($i=0;$i&lt;100;$i++)\n{\necho rand();\necho '....Scene of shooting at Nebraska shopping centre\nEight killed in Nebraska shooting\nA gunman opens fire in a shopping centre in the US state of Nebraska, killing at least eight people.\nScene of shooting at Nebraska shopping centre\nEight killed in Nebraska shooting\nA gunman opens fire in a shopping centre in the US state of Nebraska, killing at least eight people.\nScene of shooting at Nebraska shopping centre\nEight killed in Nebraska shooting\nA gunman opens fire in a shopping centre in the US state of Nebraska, killing at least eight people.\nScene of shooting at Nebraska shopping centre\nEight killed in Nebraska shooting\nA gunman opens fire in a shopping centre in the US state of Nebraska, killing at least eight people.\n';\n}\nprint \"done!\";</coolcode>\n这个做为是远程接口。\n3.下面比较CURL和fastCGI两种访问remote API的方式:\nA:走FastCGI:\n<coolcode>\ninclude \"./mod_fcgi.php\";\n$fcgi=new mod_fcgi();\n$args=\"127.0.0.1:1026\";\n$filename=\"/home/y/www/qps/http.php\";\n$fcgi-&gt;parser_open($args,$filename,$rq_err,$cgi_headers);\nprint($fcgi-&gt;parsed_output);\necho \"n=============n\";\n</coolcode>\nB:走CURL通道:\n<coolcode>\ninclude \"./curl.php\";\n$curl=&amp; new CURL();\necho $curl-&gt;get(\"http://localhost/qps/http.php\");\necho \"n=============n\";\n</coolcode>\n4我们比较FCGI方式和CURL方式的差异：\nFCGI方式进行远程调用的QPS:\n<coolcode>\nTotal transferred:      249306 bytes\nHTML transferred:       244410 bytes\nRequests per second:    275.77 [#/sec] (mean)\nTime per request:       3.626 [ms] (mean)\nTime per request:       3.626 [ms] (mean, across all concurrent requests)\nTransfer rate:          2233.76 [Kbytes/sec] received\n</coolcode>\nHTTP通道进行远程调用的QPS:\n<coolcode>\nTotal transferred:      2244515 bytes\nHTML transferred:       2240015 bytes\nRequests per second:    204.18 [#/sec] (mean)\nTime per request:       4.898 [ms] (mean)\nTime per request:       4.898 [ms] (mean, across all concurrent requests)\nTransfer rate:          14911.66 [Kbytes/sec] received\n</coolcode>\n经过多次比较，确认用fastCGI通道时，效率比http方式要高。\n但是....这个差别并不大，而且,使用lighttpd的spawn-cgi来充当fastcgi的守护进程，还不是特别稳定。\n另外，经过我的测试，只有当远程调用的结果有较多的输出时，FastCGI协议与HTTP协议相比才有优势。在通过网络传输的数据不多的情况下（就是http.php几乎没有输出的情况下），用CURL来调远端调用，反而比FastCGI方式慢（显而易见，mod_fcgi是自行封装的用PHP的socket函数来进行网络操作的class,而Curl是一个编译了的php扩展).\n因此，我忙活了半天，最后得出的结论是，目前还不能在公司大规模加以运用。\n但是对于小型企业，创业型公司来说，这种效率对比还是很有用的，可以加以挖掘。","postDate":"2007-12-06 20:57:13","postId":560,"type":"post","status":"publish","imported":true,"file":"560.md"}